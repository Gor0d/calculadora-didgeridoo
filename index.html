<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéµ Calculadora Avan√ßada de Didgeridoo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ffd700, #ffed4a);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .mode-tabs {
            display: flex;
            background: white;
            border-radius: 15px;
            margin-bottom: 30px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .mode-tab {
            flex: 1;
            padding: 15px 25px;
            background: none;
            border: none;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #7f8c8d;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .mode-tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .mode-tab:hover:not(.active) {
            background: #f8f9fa;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .mode-tabs {
                flex-direction: column;
            }
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.15);
        }

        .card h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.4em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .mode-content {
            display: none;
        }

        .mode-content.active {
            display: block;
        }

        .shape-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .shape-btn {
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 14px;
        }

        .shape-btn:hover,
        .shape-btn.active {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        textarea {
            width: 100%;
            height: 300px;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        textarea:focus {
            border-color: #667eea;
            outline: none;
        }

        .construction-inputs {
            display: grid;
            gap: 15px;
        }

        .target-selector {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 10px;
            align-items: center;
        }

        .ou-texto {
            text-align: center;
            font-weight: 600;
            color: #7f8c8d;
        }

        .freq-input, .construction-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .freq-input:focus, .construction-input:focus {
            border-color: #667eea;
            outline: none;
        }

        .tube-type-selector {
            display: grid;
            gap: 15px;
        }

        .radio-option {
            display: flex;
            align-items: center;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .radio-option:hover {
            border-color: #667eea;
        }

        .radio-option input[type="radio"] {
            display: none;
        }

        .radio-option input[type="radio"]:checked + .radio-custom {
            background: #667eea;
            border-color: #667eea;
        }

        .radio-option input[type="radio"]:checked + .radio-custom::after {
            opacity: 1;
        }

        .radio-custom {
            width: 20px;
            height: 20px;
            border: 2px solid #e0e0e0;
            border-radius: 50%;
            margin-right: 15px;
            position: relative;
            transition: all 0.3s ease;
        }

        .radio-custom::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 10px;
            height: 10px;
            background: white;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .radio-content strong {
            display: block;
            color: #2c3e50;
        }

        .radio-content small {
            color: #7f8c8d;
            font-size: 0.9em;
        }

        .param-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .param-group {
            display: flex;
            flex-direction: column;
        }

        .param-group label {
            margin-bottom: 5px;
            font-size: 14px;
            font-weight: 600;
            color: #555;
        }

        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #28a745, #20c997);
        }

        .btn-success {
            background: linear-gradient(45deg, #ffc107, #fd7e14);
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 14px;
        }

        .controls-section {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .project-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .project-name {
            flex: 1;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab {
            padding: 12px 20px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s ease;
            border-bottom: 2px solid transparent;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .visualization {
            width: 100%;
            height: 300px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: white;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .results-table th,
        .results-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }

        .results-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #555;
        }

        .results-table tr:hover {
            background: #f8f9fa;
        }

        .freq-value {
            font-weight: 600;
            color: #667eea;
        }

        .note-name {
            font-weight: 600;
            color: #e74c3c;
            font-size: 1.1em;
        }

        .cent-diff.perfect {
            color: #27ae60;
        }

        .cent-diff.positive {
            color: #e74c3c;
        }

        .drone-row {
            background: linear-gradient(90deg, rgba(231,76,60,0.1) 0%, rgba(255,255,255,0) 100%);
            border-left: 4px solid #e74c3c;
        }

        .audio-controls {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .audio-controls h3 {
            margin-bottom: 15px;
            text-align: center;
        }

        .audio-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .audio-btn {
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.3s ease;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .audio-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }

        .audio-btn.playing {
            background: #28a745;
            border-color: #28a745;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .audio-controls-advanced {
            display: grid;
            gap: 15px;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            min-width: 120px;
            font-weight: 600;
        }

        .slider {
            flex: 1;
            height: 6px;
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .audio-info {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            font-style: italic;
        }

        .audio-info.playing {
            background: rgba(46, 204, 113, 0.3);
            animation: pulse 2s infinite;
        }

        .metric-card {
            background: linear-gradient(45deg, #f8f9fa, #e9ecef);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #667eea;
        }

        .metric-card h3 {
            color: #667eea;
            margin-bottom: 5px;
            font-size: 1.1em;
        }

        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #333;
        }

        .metric-unit {
            font-size: 0.9em;
            color: #666;
            margin-left: 5px;
        }

        .construction-results {
            margin-top: 30px;
            border-top: 2px solid #ecf0f1;
            padding-top: 30px;
        }

        .result-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .result-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #ecf0f1;
        }

        .result-card.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .result-label {
            font-size: 0.9em;
            font-weight: 600;
            margin-bottom: 5px;
            opacity: 0.8;
        }

        .result-value {
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .result-note {
            font-size: 0.8em;
            opacity: 0.7;
        }

        .construction-tips h4 {
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .tips-list {
            list-style: none;
        }

        .tips-list li {
            padding: 8px 0;
            padding-left: 20px;
            position: relative;
        }

        .tips-list li::before {
            content: 'üí°';
            position: absolute;
            left: 0;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #667eea;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .success-message,
        .error-message {
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            font-weight: 600;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-analyzing {
            background: #ffc107;
            animation: pulse 1s infinite;
        }

        .status-ready {
            background: #28a745;
        }

        .status-error {
            background: #dc3545;
        }

        .footer {
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            color: white;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéµ Calculadora Avan√ßada de Didgeridoo</h1>
            <p>Ferramenta profissional para an√°lise ac√∫stica, design e constru√ß√£o de didgeridoos</p>
        </div>

        <div class="mode-tabs">
            <button class="mode-tab active" onclick="switchMode('analysis')">
                üîç An√°lise de Geometria
            </button>
            <button class="mode-tab" onclick="switchMode('construction')">
                üîß C√°lculo para Nota
            </button>
        </div>

        <div class="main-content">
            <!-- Input Section -->
            <div class="card">
                <h2>‚öôÔ∏è Configura√ß√µes</h2>
                
                <!-- Modo An√°lise -->
                <div id="analysisMode" class="mode-content active">
                    <div class="project-controls">
                        <input type="text" class="project-name" placeholder="Nome do projeto" value="Meu Didgeridoo">
                        <button class="btn btn-secondary btn-small" onclick="saveProject()">üíæ Salvar</button>
                        <button class="btn btn-secondary btn-small" onclick="loadProject()">üìÅ Carregar</button>
                    </div>

                    <div class="input-group">
                        <label>üéØ Formas Pr√©-definidas:</label>
                        <div class="shape-buttons">
                            <button class="shape-btn" onclick="loadShape('traditional')">üé∫ Tradicional</button>
                            <button class="shape-btn" onclick="loadShape('straight')">üìè Reto</button>
                            <button class="shape-btn" onclick="loadShape('bell')">üîî Campana</button>
                            <button class="shape-btn" onclick="loadShape('conical')">üìê C√¥nico</button>
                        </div>
                    </div>

                    <div class="input-group">
                        <label for="geometryInput">
                            <div class="tooltip">
                                üìê Geometria DIDGMO (posi√ß√£o[m] di√¢metro[m])
                                <span class="tooltiptext">Formato: comprimento em metros, di√¢metro em metros. Ex: 0.00 0.030</span>
                            </div>
                        </label>
                        <textarea id="geometryInput" placeholder="# Exemplo de didgeridoo tradicional
# Formato: posi√ß√£o(m) di√¢metro(m)
0.00 0.030  # Bocal: 30mm
0.10 0.032  # 10cm: 32mm
0.20 0.035  # 20cm: 35mm
0.50 0.045  # 50cm: 45mm
1.00 0.060  # 100cm: 60mm
1.50 0.080  # Final: 80mm"></textarea>
                    </div>

                    <div class="param-grid">
                        <div class="param-group">
                            <label for="soundSpeedInput">üå°Ô∏è Velocidade do Som (m/s)</label>
                            <input type="number" id="soundSpeedInput" value="343" min="300" max="400" step="1" class="construction-input">
                        </div>
                        <div class="param-group">
                            <label for="mouthpieceInput">üéØ Di√¢metro do Bocal (mm)</label>
                            <input type="number" id="mouthpieceInput" value="28" min="10" max="50" step="0.1" class="construction-input">
                        </div>
                    </div>

                    <div class="controls-section">
                        <button class="btn" onclick="analyzeGeometry()">
                            <span class="status-indicator status-ready"></span>
                            üî¨ Analisar Geometria
                        </button>
                        <button class="btn btn-success" onclick="reverseCalculate()">
                            <div class="tooltip">
                                üéØ Calculadora Reversa
                                <span class="tooltiptext">Calcula geometria para nota desejada</span>
                            </div>
                        </button>
                    </div>
                </div>

                <!-- Modo Constru√ß√£o -->
                <div id="constructionMode" class="mode-content">
                    <div class="input-group">
                        <label>üéµ Nota Alvo:</label>
                        <div class="target-selector">
                            <select id="targetNote" class="construction-input">
                                <option value="">Selecione uma nota</option>
                                <option value="69.30">C2 (69.30 Hz)</option>
                                <option value="73.42">D2 (73.42 Hz)</option>
                                <option value="82.41">E2 (82.41 Hz)</option>
                                <option value="87.31">F2 (87.31 Hz)</option>
                                <option value="98.00">G2 (98.00 Hz)</option>
                                <option value="110.00">A2 (110.00 Hz)</option>
                                <option value="123.47">B2 (123.47 Hz)</option>
                            </select>
                            <span class="ou-texto">ou</span>
                            <input type="number" id="customTargetFreq" placeholder="Frequ√™ncia (Hz)" step="0.01" class="freq-input">
                        </div>
                    </div>

                    <div class="input-group">
                        <label>üîß Tipo de Tubo:</label>
                        <div class="tube-type-selector">
                            <label class="radio-option">
                                <input type="radio" name="tubeType" value="fechado" checked>
                                <span class="radio-custom"></span>
                                <div class="radio-content">
                                    <strong>Tubo Fechado</strong>
                                    <small>Uma extremidade fechada (didgeridoo t√≠pico)</small>
                                </div>
                            </label>
                            <label class="radio-option">
                                <input type="radio" name="tubeType" value="aberto">
                                <span class="radio-custom"></span>
                                <div class="radio-content">
                                    <strong>Tubo Aberto</strong>
                                    <small>Ambas extremidades abertas</small>
                                </div>
                            </label>
                        </div>
                    </div>

                    <div class="param-grid">
                        <div class="param-group">
                            <label>üìè Di√¢metro (mm):</label>
                            <input type="number" id="targetDiameter" value="30" min="10" max="100" step="0.5" class="construction-input">
                        </div>
                        <div class="param-group">
                            <label>üß± Espessura (mm):</label>
                            <input type="number" id="wallThickness" value="3" min="1" max="20" step="0.1" class="construction-input">
                        </div>
                        <div class="param-group">
                            <label>üå≥ Material:</label>
                            <select id="materialType" class="construction-input">
                                <option value="madeira">Madeira</option>
                                <option value="bambu">Bambu</option>
                                <option value="pvc">PVC</option>
                                <option value="metal">Metal</option>
                            </select>
                        </div>
                    </div>

                    <button class="btn" onclick="calculateForNote()">
                        <span>üéØ</span> Calcular Dimens√µes
                    </button>

                    <div id="constructionResults" class="construction-results" style="display: none;">
                        <h3>üìê Dimens√µes Calculadas</h3>
                        <div class="result-cards">
                            <div class="result-card primary">
                                <div class="result-label">Comprimento Total</div>
                                <div class="result-value" id="totalLengthResult">0 mm</div>
                                <div class="result-note">Dist√¢ncia interna do bocal ao final</div>
                            </div>
                            <div class="result-card">
                                <div class="result-label">Di√¢metro Externo</div>
                                <div class="result-value" id="externalDiameterResult">0 mm</div>
                                <div class="result-note">Incluindo espessura da parede</div>
                            </div>
                            <div class="result-card">
                                <div class="result-label">Volume Interno</div>
                                <div class="result-value" id="internalVolumeResult">0 cm¬≥</div>
                                <div class="result-note">Volume de ar no tubo</div>
                            </div>
                        </div>

                        <div class="construction-tips">
                            <h4>üí° Dicas de Constru√ß√£o:</h4>
                            <div id="constructionTips"></div>
                        </div>
                    </div>
                </div>

                <div class="controls-section">
                    <button class="btn btn-secondary" onclick="exportData()">üìä Exportar CSV</button>
                </div>

                <div id="statusMessage"></div>
            </div>

            <!-- Results Section -->
            <div class="card">
                <h2>üìä Resultados da An√°lise</h2>
                
                <div class="audio-controls">
                    <h3>üîä Preview Sonoro</h3>
                    <div class="audio-buttons">
                        <button class="audio-btn" onclick="playDrone()">
                            üéµ Drone
                        </button>
                        <button class="audio-btn" onclick="playHarmonics()">
                            üé∫ Trombetas
                        </button>
                        <button class="audio-btn" onclick="playFullSpectrum()">
                            üéº Espectro Completo
                        </button>
                        <button class="audio-btn" onclick="stopAllAudio()">
                            ‚èπÔ∏è Parar
                        </button>
                    </div>
                    
                    <div class="audio-controls-advanced">
                        <div class="control-group">
                            <label for="volumeControl">üîä Volume:</label>
                            <input type="range" id="volumeControl" min="0" max="100" value="30" class="slider">
                            <span id="volumeValue">30%</span>
                        </div>
                        
                        <div class="control-group">
                            <label for="durationControl">‚è±Ô∏è Dura√ß√£o:</label>
                            <input type="range" id="durationControl" min="1" max="10" value="3" class="slider">
                            <span id="durationValue">3s</span>
                        </div>
                        
                        <div class="control-group">
                            <label for="breathingControl">üí® Respira√ß√£o Circular:</label>
                            <input type="checkbox" id="breathingControl" checked>
                        </div>
                    </div>
                    
                    <div class="audio-info" id="audioInfo">
                        <p>Execute a an√°lise para gerar preview sonoro</p>
                    </div>
                </div>

                <div class="tabs">
                    <button class="tab active" onclick="showTab('results')">üìà Resultados</button>
                    <button class="tab" onclick="showTab('visualization')">üìä Visualiza√ß√£o</button>
                    <button class="tab" onclick="showTab('metrics')">üìã M√©tricas</button>
                </div>

                <div id="results" class="tab-content active">
                    <div class="loading" id="loadingIndicator">
                        <div class="spinner"></div>
                        <p>Analisando geometria...</p>
                    </div>
                    
                    <table class="results-table" id="resultsTable">
                        <thead>
                            <tr>
                                <th>Harm√¥nico</th>
                                <th>Freq. (Hz)</th>
                                <th>Nota</th>
                                <th>Oitava</th>
                                <th>Cents</th>
                                <th>Imped√¢ncia</th>
                            </tr>
                        </thead>
                        <tbody id="resultsBody">
                            <tr>
                                <td colspan="6" style="text-align: center; color: #666; padding: 30px;">
                                    Insira uma geometria e clique em "Analisar" para ver os resultados
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div id="visualization" class="tab-content">
                    <div class="tabs">
                        <button class="tab active" onclick="showVisualization('geometry')">üìê Geometria</button>
                        <button class="tab" onclick="showVisualization('impedance')">üìä Imped√¢ncia</button>
                        <button class="tab" onclick="showVisualization('spectrum')">üéµ Espectro</button>
                    </div>
                    <canvas id="visualizationCanvas" class="visualization"></canvas>
                </div>

                <div id="metrics" class="tab-content">
                    <div id="metricsContainer">
                        <div class="metric-card">
                            <h3>üìè Comprimento Total</h3>
                            <div class="metric-value">--<span class="metric-unit">mm</span></div>
                        </div>
                        <div class="metric-card">
                            <h3>‚≠ï Di√¢metro M√©dio</h3>
                            <div class="metric-value">--<span class="metric-unit">mm</span></div>
                        </div>
                        <div class="metric-card">
                            <h3>üéµ Nota Fundamental</h3>
                            <div class="metric-value">--<span class="metric-unit">Hz</span></div>
                        </div>
                        <div class="metric-card">
                            <h3>üéØ Precis√£o</h3>
                            <div class="metric-value">--</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <footer class="footer">
            <p>üéµ Desenvolvido para m√∫sicos e luthiers</p>
            <p>Baseado em princ√≠pios de ac√∫stica e f√≠sica ondulat√≥ria</p>
        </footer>
    </div>

    <script>
        // Configura√ß√µes globais
        const CONFIG = {
            MAX_HARMONICS: 8,
            MIN_FREQUENCY: 50,
            MAX_FREQUENCY: 1000,
            CANVAS_MARGIN: 60,
            NOTE_BASE_FREQ: {
                'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13, 'E': 329.63,
                'F': 349.23, 'F#': 369.99, 'G': 392.00, 'G#': 415.30, 'A': 440.00,
                'A#': 466.16, 'B': 493.88
            },
            NOTE_NAMES: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']
        };

        // Estado da aplica√ß√£o
        let appState = {
            currentMode: 'analysis',
            currentGeometry: [],
            analysisResults: [],
            currentVisualization: 'geometry',
            audioContext: null,
            oscillators: [],
            isPlaying: false,
            isAnalyzing: false
        };

        // Formas pr√©-definidas (formato DIDGMO em metros)
        const PREDEFINED_SHAPES = {
            traditional: `# Didgeridoo Tradicional Australiano
# Formato: posi√ß√£o(m) di√¢metro(m)
0.00 0.030  # Bocal: 30mm
0.10 0.032  # 10cm: ligeiro alargamento
0.20 0.035  # 20cm: continua√ß√£o suave
0.50 0.045  # 50cm: meio do instrumento
1.00 0.060  # 100cm: expans√£o gradual
1.30 0.070  # 130cm: pr√©-campana
1.50 0.080  # Final: campana 80mm`,
            
            straight: `# Tubo Reto Uniforme
# Formato: posi√ß√£o(m) di√¢metro(m)
0.00 0.040  # In√≠cio: 40mm
0.50 0.040  # Meio: 40mm
1.00 0.040  # Tr√™s quartos: 40mm
1.50 0.040  # Final: 40mm`,
            
            bell: `# Formato Campana (Bell)
# Formato: posi√ß√£o(m) di√¢metro(m)
0.00 0.030  # Bocal: 30mm
0.50 0.035  # Meio: pequeno aumento
1.00 0.045  # In√≠cio da campana
1.30 0.065  # Expans√£o da campana
1.50 0.090  # Final: campana larga`,
            
            conical: `# Formato C√¥nico Linear
# Formato: posi√ß√£o(m) di√¢metro(m)
0.00 0.025  # Bocal: 25mm (estreito)
0.30 0.035  # 30cm: expans√£o gradual
0.60 0.045  # 60cm: continua√ß√£o
0.90 0.055  # 90cm: expandindo
1.20 0.065  # 120cm: quase no final
1.50 0.075  # Final: 75mm`
        };

        // Inicializa√ß√£o
        document.addEventListener('DOMContentLoaded', function() {
            setupAudioContext();
            setupEventListeners();
            loadDefaultGeometry();
            setupAudioControls();
        });

        function setupAudioContext() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                appState.audioContext = audioContext;
            } catch (e) {
                console.warn('Web Audio API n√£o suportada:', e);
            }
        }

        function setupEventListeners() {
            // Auto-an√°lise com debounce
            let timeout;
            document.getElementById('geometryInput').addEventListener('input', function() {
                clearTimeout(timeout);
                timeout = setTimeout(analyzeGeometry, 1000);
            });

            // Parar √°udio quando mudan√ßa de geometria
            document.getElementById('geometryInput').addEventListener('input', function() {
                stopAllAudio();
            });
        }

        function setupAudioControls() {
            // Volume control
            const volumeControl = document.getElementById('volumeControl');
            const volumeValue = document.getElementById('volumeValue');
            
            volumeControl.addEventListener('input', function() {
                volumeValue.textContent = this.value + '%';
            });

            // Duration control
            const durationControl = document.getElementById('durationControl');
            const durationValue = document.getElementById('durationValue');
            
            durationControl.addEventListener('input', function() {
                durationValue.textContent = this.value + 's';
            });
        }

        function loadDefaultGeometry() {
            document.getElementById('geometryInput').value = PREDEFINED_SHAPES.traditional;
        }

        // Altern√¢ncia entre modos
        function switchMode(mode) {
            appState.currentMode = mode;
            
            // Atualizar tabs
            document.querySelectorAll('.mode-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            
            // Mostrar/esconder conte√∫do
            document.querySelectorAll('.mode-content').forEach(content => content.classList.remove('active'));
            
            if (mode === 'analysis') {
                document.getElementById('analysisMode').classList.add('active');
            } else {
                document.getElementById('constructionMode').classList.add('active');
            }
            
            showMessage(`üìã Modo alterado para: ${mode === 'analysis' ? 'An√°lise de Geometria' : 'C√°lculo para Nota'}`);
        }

        // Carregar formas pr√©-definidas
        function loadShape(shapeType) {
            try {
                const shapeData = PREDEFINED_SHAPES[shapeType];
                if (!shapeData) {
                    throw new Error('Forma n√£o encontrada');
                }
                
                document.getElementById('geometryInput').value = shapeData;
                
                // Atualizar bot√£o ativo
                document.querySelectorAll('.shape-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                event.target.classList.add('active');
                
                showMessage(`‚úÖ Forma "${shapeType}" carregada com sucesso`);
                
                // Analisar automaticamente ap√≥s 500ms
                setTimeout(() => analyzeGeometry(), 500);
                
            } catch (error) {
                showMessage(`‚ùå Erro ao carregar forma: ${error.message}`, 'error');
            }
        }

        // Parser de geometria (formato DIDGMO)
        function parseGeometry(input) {
            try {
                const geometryText = input || document.getElementById('geometryInput').value.trim();
                const lines = geometryText.split('\n');
                const points = [];
                
                for (let line of lines) {
                    line = line.trim();
                    if (line === '' || line.startsWith('#')) continue;
                    
                    const parts = line.split(/\s+/);
                    if (parts.length >= 2) {
                        const position = parseFloat(parts[0]); // em metros
                        const diameter = parseFloat(parts[1]); // em metros
                        
                        if (!isNaN(position) && !isNaN(diameter) && diameter > 0) {
                            points.push({ 
                                position: position * 1000, // converter para mm
                                diameter: diameter * 1000   // converter para mm
                            });
                        }
                    }
                }
                
                if (points.length < 2) {
                    throw new Error('√â necess√°rio pelo menos 2 pontos de geometria');
                }
                
                // Ordenar por posi√ß√£o
                points.sort((a, b) => a.position - b.position);
                
                return points;
            } catch (error) {
                console.error('Erro no parsing da geometria:', error);
                throw error;
            }
        }

        // C√°lculo de frequ√™ncias usando an√°lise de imped√¢ncia
        function calculateFrequencies() {
            const soundSpeed = parseFloat(document.getElementById('soundSpeedInput').value) || 343;
            const totalLength = appState.currentGeometry[appState.currentGeometry.length - 1].position / 1000; // converter para metros
            
            const results = [];
            
            // Calcular frequ√™ncia fundamental baseada no comprimento efetivo
            const avgDiameter = appState.currentGeometry.reduce((sum, point, index, arr) => {
                if (index === 0) return point.diameter;
                const prevPoint = arr[index - 1];
                const segmentLength = point.position - prevPoint.position;
                const avgSegmentDiam = (point.diameter + prevPoint.diameter) / 2;
                return sum + avgSegmentDiam * segmentLength;
            }, 0) / (appState.currentGeometry[appState.currentGeometry.length - 1].position);
            
            // Corre√ß√£o de extremidade para abertura
            const endCorrection = 0.6 * (avgDiameter / 1000); // em metros
            const effectiveLength = totalLength + endCorrection;
            
            // Frequ√™ncia fundamental aproximada
            const fundamentalFreq = soundSpeed / (4 * effectiveLength);
            
            // Gerar harm√¥nicos com corre√ß√µes para geometria c√¥nica
            for (let n = 1; n <= CONFIG.MAX_HARMONICS; n++) {
                let frequency;
                
                if (n === 1) {
                    // Drone (fundamental)
                    frequency = fundamentalFreq;
                } else {
                    // Harm√¥nicos superiores com corre√ß√£o para conicidade
                    const harmonicOrder = 2 * n - 1;
                    const conicityFactor = 1 + (avgDiameter / 1000) / (4 * effectiveLength);
                    frequency = harmonicOrder * fundamentalFreq * conicityFactor;
                }
                
                if (frequency >= CONFIG.MIN_FREQUENCY && frequency <= CONFIG.MAX_FREQUENCY) {
                    const noteInfo = findClosestNote(frequency);
                    
                    // Calcular imped√¢ncia relativa
                    const impedance = calculateImpedance(frequency, effectiveLength, avgDiameter / 1000);
                    
                    results.push({
                        frequency: frequency,
                        harmonic: n,
                        note: noteInfo.note,
                        octave: noteInfo.octave,
                        centDiff: noteInfo.centDiff,
                        impedance: impedance,
                        type: n === 1 ? 'Drone' : 'Trombeta'
                    });
                }
            }
            
            return results;
        }

        // Calcular imped√¢ncia para uma frequ√™ncia espec√≠fica
        function calculateImpedance(frequency, length, avgDiameter) {
            const c = 343; // velocidade do som
            const k = 2 * Math.PI * frequency / c; // n√∫mero de onda
            const ka = k * avgDiameter / 2; // ka (adimensional)
            
            // Modelo simplificado de imped√¢ncia para tubo c√¥nico
            const Z0 = 415; // imped√¢ncia caracter√≠stica do ar (Pa¬∑s/m¬≥)
            const kL = k * length;
            
            // Imped√¢ncia de entrada para tubo fechado c√¥nico
            const impedance = Z0 * Math.abs(1 / Math.tan(kL)) * (1 + 0.5 * ka);
            
            return impedance / 1000000; // Converter para MŒ©
        }

        // Encontrar nota mais pr√≥xima
        function findClosestNote(frequency) {
            let closestNote = 'C';
            let closestOctave = 2;
            let minDiff = Infinity;
            
            // Expandir range de oitavas para cobrir frequ√™ncias baixas do didgeridoo
            for (let octave = 0; octave < 6; octave++) {
                for (let noteName of CONFIG.NOTE_NAMES) {
                    const noteFreq = CONFIG.NOTE_BASE_FREQ[noteName] * Math.pow(2, octave - 4);
                    const diff = Math.abs(frequency - noteFreq);
                    
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestNote = noteName;
                        closestOctave = octave;
                    }
                }
            }
            
            const exactFreq = CONFIG.NOTE_BASE_FREQ[closestNote] * Math.pow(2, closestOctave - 4);
            const centDiff = 1200 * Math.log2(frequency / exactFreq);
            
            return {
                note: closestNote,
                octave: closestOctave,
                centDiff: Math.round(centDiff * 10) / 10
            };
        }

        // Fun√ß√£o principal de an√°lise
        async function analyzeGeometry() {
            if (appState.isAnalyzing) {
                showMessage('‚è≥ An√°lise j√° est√° em andamento...', 'error');
                return;
            }
            
            try {
                showLoading(true);
                showMessage('üîç Iniciando an√°lise...');
                
                // Parse da geometria
                appState.currentGeometry = parseGeometry();
                
                // Pequena pausa para UX
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Calcular frequ√™ncias
                appState.analysisResults = calculateFrequencies();
                
                // Exibir resultados
                displayResults(appState.analysisResults);
                displayMetrics(appState.currentGeometry, appState.analysisResults);
                updateVisualization();
                updateAudioInfo();
                
                showMessage(`‚úÖ An√°lise conclu√≠da! ${appState.analysisResults.length} frequ√™ncias calculadas`);
                
            } catch (error) {
                console.error('Erro na an√°lise:', error);
                showMessage(`‚ùå Erro na an√°lise: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }

        // Calculadora reversa
        function reverseCalculate() {
            const targetNote = prompt('Digite a nota desejada (ex: D2, A3):');
            if (!targetNote) return;
            
            const noteMap = {
                'C': 16.35, 'C#': 17.32, 'D': 18.35, 'D#': 19.45,
                'E': 20.60, 'F': 21.83, 'F#': 23.12, 'G': 24.50,
                'G#': 25.96, 'A': 27.50, 'A#': 29.14, 'B': 30.87
            };
            
            const match = targetNote.match(/([A-G]#?)(\d+)/);
            if (!match) {
                alert('Formato inv√°lido. Use formato como D2, A3, etc.');
                return;
            }
            
            const noteName = match[1];
            const octave = parseInt(match[2]);
            const baseFreq = noteMap[noteName];
            const targetFreq = baseFreq * Math.pow(2, octave);
            
            // Calcular comprimento necess√°rio
            const soundSpeed = parseFloat(document.getElementById('soundSpeedInput').value) || 343;
            const targetLength = soundSpeed / (4 * targetFreq);
            
            // Gerar geometria para o comprimento calculado
            const lengthMm = targetLength * 1000;
            const geometry = `# Calculado para ${targetNote} (${targetFreq.toFixed(1)} Hz)
# Formato: posi√ß√£o(m) di√¢metro(m)
0.00 0.030
${(lengthMm * 0.1 / 1000).toFixed(3)} 0.032
${(lengthMm * 0.3 / 1000).toFixed(3)} 0.038
${(lengthMm * 0.6 / 1000).toFixed(3)} 0.050
${(lengthMm * 0.9 / 1000).toFixed(3)} 0.065
${(lengthMm / 1000).toFixed(3)} 0.080`;
            
            document.getElementById('geometryInput').value = geometry;
            analyzeGeometry();
        }

        // Calcular dimens√µes para nota espec√≠fica
        function calculateForNote() {
            try {
                // Obter dados de entrada
                const targetNoteSelect = document.getElementById('targetNote');
                const customTargetFreq = document.getElementById('customTargetFreq');
                const tubeTypeRadios = document.getElementsByName('tubeType');
                const targetDiameter = parseFloat(document.getElementById('targetDiameter').value);
                const wallThickness = parseFloat(document.getElementById('wallThickness').value);
                const materialType = document.getElementById('materialType').value;
                const soundSpeed = parseFloat(document.getElementById('soundSpeedInput').value);

                // Obter frequ√™ncia alvo
                let targetFrequency = 0;
                if (customTargetFreq.value && customTargetFreq.value.trim() !== '') {
                    targetFrequency = parseFloat(customTargetFreq.value);
                } else if (targetNoteSelect.value && targetNoteSelect.value.trim() !== '') {
                    targetFrequency = parseFloat(targetNoteSelect.value);
                }

                if (targetFrequency <= 0 || isNaN(targetFrequency)) {
                    throw new Error('Por favor, selecione uma nota ou digite uma frequ√™ncia v√°lida!');
                }

                // Obter tipo de tubo
                let tubeType = 'fechado';
                for (let radio of tubeTypeRadios) {
                    if (radio.checked) {
                        tubeType = radio.value;
                        break;
                    }
                }

                // Calcular comprimento baseado no tipo de tubo
                let length;
                if (tubeType === 'fechado') {
                    length = soundSpeed / (4 * targetFrequency);
                } else {
                    length = soundSpeed / (2 * targetFrequency);
                }

                const lengthMM = length * 1000;
                const externalDiameter = targetDiameter + (wallThickness * 2);
                const internalVolume = Math.PI * Math.pow(targetDiameter / 2, 2) * length / 1000;

                // Exibir resultados
                displayConstructionResults({
                    targetFrequency,
                    tubeType,
                    length: lengthMM,
                    diameter: targetDiameter,
                    externalDiameter,
                    wallThickness,
                    internalVolume,
                    material: materialType,
                    soundSpeed
                });

                showMessage(`‚úÖ Dimens√µes calculadas para ${targetFrequency.toFixed(2)} Hz!`);

            } catch (error) {
                console.error('Erro no c√°lculo:', error);
                showMessage(`‚ùå ${error.message}`, 'error');
            }
        }

        // Exibir resultados da constru√ß√£o
        function displayConstructionResults(data) {
            document.getElementById('totalLengthResult').textContent = `${data.length.toFixed(1)} mm`;
            document.getElementById('externalDiameterResult').textContent = `${data.externalDiameter.toFixed(1)} mm`;
            document.getElementById('internalVolumeResult').textContent = `${data.internalVolume.toFixed(1)} cm¬≥`;

            // Gerar dicas de constru√ß√£o
            const tips = generateConstructionTips(data);
            document.getElementById('constructionTips').innerHTML = tips;

            // Mostrar se√ß√£o de resultados
            document.getElementById('constructionResults').style.display = 'block';
            document.getElementById('constructionResults').classList.add('fade-in');
        }

        // Gerar dicas de constru√ß√£o
        function generateConstructionTips(data) {
            const tips = [];

            switch (data.material) {
                case 'madeira':
                    tips.push('Use madeira seca e bem curada para evitar rachaduras');
                    tips.push('Madeiras como eucalipto, bambu ou cedro s√£o ideais');
                    break;
                case 'bambu':
                    tips.push('Escolha bambu maduro com paredes espessas');
                    tips.push('Remova todos os n√≥s internos cuidadosamente');
                    break;
                case 'pvc':
                    tips.push('Use PVC de qualidade para evitar toxicidade');
                    tips.push('PVC √© ideal para prot√≥tipos e testes');
                    break;
                case 'metal':
                    tips.push('Use metal n√£o t√≥xico (alum√≠nio ou cobre)');
                    tips.push('Polir o interior melhora a qualidade sonora');
                    break;
            }

            if (data.length > 1500) {
                tips.push('Tubo longo: considere fazer em se√ß√µes para facilitar o transporte');
            }

            const tipsHTML = tips.map(tip => `<li>${tip}</li>`).join('');
            return `<ul class="tips-list">${tipsHTML}</ul>`;
        }

        // Exibi√ß√£o dos resultados
        function displayResults(results) {
            const tbody = document.getElementById('resultsBody');
            tbody.innerHTML = '';
            
            if (results.length === 0) {
                const row = tbody.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 6;
                cell.textContent = 'Nenhuma frequ√™ncia encontrada no intervalo de 50-1000 Hz';
                cell.style.fontStyle = 'italic';
                cell.style.color = '#7f8c8d';
                cell.style.padding = '30px';
                return;
            }
            
            results.forEach(result => {
                const row = tbody.insertRow();
                row.classList.add('fade-in');
                
                if (result.harmonic === 1) {
                    row.classList.add('drone-row');
                }
                
                // Harm√¥nico
                const harmCell = row.insertCell();
                if (result.harmonic === 1) {
                    harmCell.innerHTML = '<span style="color: #e74c3c; font-weight: bold;">Drone</span>';
                } else {
                    harmCell.textContent = `${result.harmonic}¬∫`;
                }
                
                // Frequ√™ncia
                const freqCell = row.insertCell();
                freqCell.innerHTML = `<span class="freq-value">${Math.round(result.frequency)}</span>`;
                
                // Nota
                const noteCell = row.insertCell();
                noteCell.innerHTML = `<span class="note-name">${result.note}</span>`;
                
                // Oitava
                const octaveCell = row.insertCell();
                octaveCell.textContent = result.octave;
                
                // Desvio em centavos
                const centCell = row.insertCell();
                let centClass = 'perfect';
                if (Math.abs(result.centDiff) > 50) centClass = 'positive';
                else if (Math.abs(result.centDiff) > 10) centClass = 'positive';
                
                const sign = result.centDiff > 0 ? '+' : '';
                centCell.innerHTML = `<span class="cent-diff ${centClass}">${sign}${result.centDiff}</span>`;
                
                // Imped√¢ncia
                const impedanceCell = row.insertCell();
                impedanceCell.innerHTML = `<span class="impedance-value">${result.impedance.toFixed(3)}</span>`;
            });
        }

        function displayMetrics(geometry, results) {
            const container = document.getElementById('metricsContainer');
            if (!geometry.length || !results.length) return;
            
            const totalLength = geometry[geometry.length - 1].position;
            const avgDiameter = geometry.reduce((sum, point) => sum + point.diameter, 0) / geometry.length;
            const fundamental = results[0];
            
            container.innerHTML = `
                <div class="metric-card">
                    <h3>üìè Comprimento Total</h3>
                    <div class="metric-value">${(totalLength / 10).toFixed(1)}<span class="metric-unit">cm</span></div>
                </div>
                <div class="metric-card">
                    <h3>‚≠ï Di√¢metro M√©dio</h3>
                    <div class="metric-value">${avgDiameter.toFixed(1)}<span class="metric-unit">mm</span></div>
                </div>
                <div class="metric-card">
                    <h3>üéµ Nota Fundamental</h3>
                    <div class="metric-value">${fundamental.note}${fundamental.octave} <span class="metric-unit">(${fundamental.frequency.toFixed(1)} Hz)</span></div>
                </div>
                <div class="metric-card">
                    <h3>üéØ Precis√£o</h3>
                    <div class="metric-value">${Math.abs(fundamental.centDiff) < 10 ? '‚úÖ Afinado' : Math.abs(fundamental.centDiff) < 30 ? '‚ö†Ô∏è Aceit√°vel' : '‚ùå Desafinado'}</div>
                </div>
            `;
        }

        function showTab(tabName) {
            document.querySelectorAll('#results, #visualization, #metrics').forEach(content => content.classList.remove('active'));
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
            
            if (tabName === 'visualization') {
                updateVisualization();
            }
        }

        function showVisualization(type) {
            appState.currentVisualization = type;
            document.querySelectorAll('#visualization .tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            updateVisualization();
        }

        function updateVisualization() {
            const canvas = document.getElementById('visualizationCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (appState.currentGeometry.length === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Execute a an√°lise para ver a visualiza√ß√£o', canvas.width/2, canvas.height/2);
                return;
            }
            
            switch (appState.currentVisualization) {
                case 'geometry':
                    drawGeometry(ctx, canvas);
                    break;
                case 'impedance':
                    drawImpedance(ctx, canvas);
                    break;
                case 'spectrum':
                    drawSpectrum(ctx, canvas);
                    break;
            }
        }

        function drawGeometry(ctx, canvas) {
            const geometry = appState.currentGeometry;
            if (geometry.length < 2) return;
            
            const maxLength = geometry[geometry.length - 1].position;
            const maxDiameter = Math.max(...geometry.map(p => p.diameter));
            
            const margin = 40;
            const scaleX = (canvas.width - margin * 2) / maxLength;
            const scaleY = (canvas.height - margin * 2) / maxDiameter;
            
            // Desenhar o contorno do didgeridoo
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            // Parte superior
            for (let i = 0; i < geometry.length; i++) {
                const x = margin + geometry[i].position * scaleX;
                const y = canvas.height / 2 - geometry[i].diameter * scaleY / 2;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            
            // Parte inferior (espelhada)
            for (let i = geometry.length - 1; i >= 0; i--) {
                const x = margin + geometry[i].position * scaleX;
                const y = canvas.height / 2 + geometry[i].diameter * scaleY / 2;
                ctx.lineTo(x, y);
            }
            
            ctx.closePath();
            ctx.stroke();
            
            // Preencher com gradiente
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            gradient.addColorStop(0, 'rgba(102, 126, 234, 0.3)');
            gradient.addColorStop(1, 'rgba(118, 75, 162, 0.3)');
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Desenhar pontos de controle
            ctx.fillStyle = '#dc3545';
            geometry.forEach(point => {
                const x = margin + point.position * scaleX;
                const y = canvas.height / 2;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Linha central
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(margin, canvas.height / 2);
            ctx.lineTo(canvas.width - margin, canvas.height / 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Segoe UI';
            ctx.fillText('Bocal', margin + 5, canvas.height / 2 - 10);
            ctx.fillText('Campana', canvas.width - margin - 50, canvas.height / 2 - 10);
        }

        function drawImpedance(ctx, canvas) {
            if (appState.analysisResults.length === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Execute a an√°lise para ver o espectro de imped√¢ncia', canvas.width/2, canvas.height/2);
                return;
            }
            
            const margin = 60;
            const maxFreq = 1000;
            const scaleX = (canvas.width - margin * 2) / maxFreq;
            const scaleY = canvas.height - margin * 2;
            
            // Desenhar eixos
            ctx.strokeStyle = '#bdc3c7';
            ctx.lineWidth = 2;
            
            // Eixo X
            ctx.beginPath();
            ctx.moveTo(margin, canvas.height - margin);
            ctx.lineTo(canvas.width - margin, canvas.height - margin);
            ctx.stroke();
            
            // Eixo Y
            ctx.beginPath();
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, canvas.height - margin);
            ctx.stroke();
            
            // Labels dos eixos
            ctx.fillStyle = '#2c3e50';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Frequ√™ncia (Hz)', canvas.width/2, canvas.height - 10);
            
            ctx.save();
            ctx.translate(20, canvas.height/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('Imped√¢ncia (MŒ©)', 0, 0);
            ctx.restore();
            
            // Desenhar picos de resson√¢ncia
            appState.analysisResults.forEach((result, index) => {
                const freq = result.frequency;
                const x = margin + freq * scaleX;
                
                if (freq <= maxFreq) {
                    const peakHeight = Math.max(0.1, 1.0 / Math.sqrt(result.harmonic));
                    const peakY = canvas.height - margin - peakHeight * scaleY * 0.8;
                    
                    // Desenhar pico
                    ctx.strokeStyle = index === 0 ? '#e74c3c' : '#667eea';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    
                    const bandwidth = 15;
                    for (let f = freq - bandwidth; f <= freq + bandwidth; f += 2) {
                        if (f >= 0 && f <= maxFreq) {
                            const xPeak = margin + f * scaleX;
                            const gaussian = Math.exp(-Math.pow((f - freq) / (bandwidth/3), 2));
                            const yPeak = canvas.height - margin - (0.1 + peakHeight * gaussian) * scaleY * 0.8;
                            
                            if (f === freq - bandwidth) {
                                ctx.moveTo(xPeak, yPeak);
                            } else {
                                ctx.lineTo(xPeak, yPeak);
                            }
                        }
                    }
                    ctx.stroke();
                    
                    // Marcar frequ√™ncia
                    ctx.fillStyle = index === 0 ? '#e74c3c' : '#667eea';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${freq.toFixed(0)}`, x, peakY - 10);
                }
            });
        }

        function drawSpectrum(ctx, canvas) {
            if (appState.analysisResults.length === 0) {
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Execute a an√°lise para ver o espectro sonoro', canvas.width/2, canvas.height/2);
                return;
            }
            
            const margin = 60;
            const maxImpedance = Math.max(...appState.analysisResults.map(r => r.impedance));
            const barWidth = (canvas.width - margin * 2) / appState.analysisResults.length;
            
            // Desenhar eixos
            ctx.strokeStyle = '#bdc3c7';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin, canvas.height - margin);
            ctx.lineTo(canvas.width - margin, canvas.height - margin);
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, canvas.height - margin);
            ctx.stroke();
            
            appState.analysisResults.forEach((result, i) => {
                const x = margin + i * barWidth;
                const height = (result.impedance / maxImpedance) * (canvas.height - margin * 2) * 0.8;
                const y = canvas.height - margin - height;
                
                // Cor baseada no tipo
                const color = result.harmonic === 1 ? '#e74c3c' : '#667eea';
                ctx.fillStyle = color;
                ctx.fillRect(x + 2, y, barWidth - 4, height);
                
                // Labels
                ctx.fillStyle = '#333';
                ctx.font = '10px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText(`${result.harmonic}¬∞`, x + barWidth/2, canvas.height - margin + 15);
                ctx.fillText(`${result.frequency.toFixed(0)}Hz`, x + barWidth/2, canvas.height - margin + 30);
            });
            
            // Labels dos eixos
            ctx.fillStyle = '#2c3e50';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Harm√¥nicos', canvas.width/2, canvas.height - 10);
            
            ctx.save();
            ctx.translate(20, canvas.height/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('Amplitude', 0, 0);
            ctx.restore();
        }

        // Fun√ß√µes de √°udio
        function initAudioContext() {
            if (!appState.audioContext) {
                try {
                    appState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API n√£o suportada:', e);
                    return null;
                }
            }
            return appState.audioContext;
        }

        function createOscillator(frequency, type = 'sawtooth', gain = 0.1) {
            const audioCtx = initAudioContext();
            if (!audioCtx) return null;
            
            const oscillator = audioCtx.createOscillator();
            oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
            oscillator.type = type;
            
            const gainNode = audioCtx.createGain();
            gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
            
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(frequency * 3, audioCtx.currentTime);
            filter.Q.setValueAtTime(2, audioCtx.currentTime);
            
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            return { oscillator, gainNode, filter };
        }

        function addBreathingEffect(gainNode, audioCtx, duration) {
            const breathingRate = 0.3;
            const breathingDepth = 0.3;
            
            for (let t = 0; t < duration; t += 0.1) {
                const time = audioCtx.currentTime + t;
                const breathing = 1 + breathingDepth * Math.sin(2 * Math.PI * breathingRate * t);
                gainNode.gain.linearRampToValueAtTime(
                    gainNode.gain.value * breathing, 
                    time
                );
            }
        }

        function playDrone() {
            if (appState.analysisResults.length === 0) {
                showMessage('‚ùå Execute a an√°lise primeiro!', 'error');
                return;
            }

            stopAllAudio();

            const droneFreq = appState.analysisResults[0].frequency;
            const volume = document.getElementById('volumeControl').value / 100;
            const duration = parseFloat(document.getElementById('durationControl').value);
            const hasBreathing = document.getElementById('breathingControl').checked;

            const audioCtx = initAudioContext();
            if (!audioCtx) return;
            
            const fundamental = createOscillator(droneFreq, 'sawtooth', volume * 0.8);
            if (!fundamental) return;
            
            const harmonics = [];
            for (let i = 1; i < Math.min(4, appState.analysisResults.length); i++) {
                const harmFreq = appState.analysisResults[i].frequency;
                const harmGain = volume * 0.3 / (i + 1);
                const harmonic = createOscillator(harmFreq, 'sine', harmGain);
                if (harmonic) harmonics.push(harmonic);
            }

            // Envelope ADSR
            const attack = 0.1;
            const decay = 0.3;
            const sustain = 0.7;
            const release = 0.5;

            fundamental.gainNode.gain.linearRampToValueAtTime(volume * 0.8, audioCtx.currentTime + attack);
            fundamental.gainNode.gain.linearRampToValueAtTime(volume * 0.8 * sustain, audioCtx.currentTime + attack + decay);
            fundamental.gainNode.gain.setValueAtTime(volume * 0.8 * sustain, audioCtx.currentTime + duration - release);
            fundamental.gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration);

            harmonics.forEach((harmonic, index) => {
                const harmVolume = volume * 0.3 / (index + 2);
                harmonic.gainNode.gain.linearRampToValueAtTime(harmVolume, audioCtx.currentTime + attack);
                harmonic.gainNode.gain.linearRampToValueAtTime(harmVolume * sustain, audioCtx.currentTime + attack + decay);
                harmonic.gainNode.gain.setValueAtTime(harmVolume * sustain, audioCtx.currentTime + duration - release);
                harmonic.gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration);
            });

            if (hasBreathing) {
                addBreathingEffect(fundamental.gainNode, audioCtx, duration);
                harmonics.forEach(harmonic => {
                    addBreathingEffect(harmonic.gainNode, audioCtx, duration);
                });
            }

            fundamental.oscillator.start(audioCtx.currentTime);
            fundamental.oscillator.stop(audioCtx.currentTime + duration);
            
            harmonics.forEach(harmonic => {
                harmonic.oscillator.start(audioCtx.currentTime);
                harmonic.oscillator.stop(audioCtx.currentTime + duration);
            });

            appState.oscillators = [fundamental, ...harmonics];
            appState.isPlaying = true;

            // UI feedback
            document.querySelector('.audio-btn').classList.add('playing');
            document.getElementById('audioInfo').innerHTML = `üéµ Tocando drone: ${Math.round(droneFreq)} Hz (${appState.analysisResults[0].note}${appState.analysisResults[0].octave})`;
            document.getElementById('audioInfo').classList.add('playing');

            setTimeout(() => {
                stopAllAudio();
            }, duration * 1000);
        }

        function playHarmonics() {
            if (appState.analysisResults.length < 2) {
                showMessage('‚ùå N√£o h√° harm√¥nicos suficientes!', 'error');
                return;
            }

            stopAllAudio();

            const volume = document.getElementById('volumeControl').value / 100;
            const duration = parseFloat(document.getElementById('durationControl').value);
            const audioCtx = initAudioContext();
            if (!audioCtx) return;

            const harmonicOscillators = [];

            appState.analysisResults.slice(1, 6).forEach((result, index) => {
                const delay = index * 0.3;
                const harmDuration = 0.8;
                
                setTimeout(() => {
                    if (!appState.isPlaying) return;
                    
                    const harmonic = createOscillator(result.frequency, 'triangle', volume * 0.6);
                    if (!harmonic) return;
                    
                    harmonic.gainNode.gain.linearRampToValueAtTime(volume * 0.6, audioCtx.currentTime + 0.05);
                    harmonic.gainNode.gain.linearRampToValueAtTime(volume * 0.4, audioCtx.currentTime + 0.2);
                    harmonic.gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + harmDuration);
                    
                    harmonic.filter.frequency.setValueAtTime(result.frequency * 2, audioCtx.currentTime);
                    
                    harmonic.oscillator.start(audioCtx.currentTime);
                    harmonic.oscillator.stop(audioCtx.currentTime + harmDuration);
                    
                    harmonicOscillators.push(harmonic);
                }, delay * 1000);
            });

            appState.oscillators = harmonicOscillators;
            appState.isPlaying = true;

            document.querySelectorAll('.audio-btn')[1].classList.add('playing');
            document.getElementById('audioInfo').innerHTML = `üé∫ Tocando trombetas: ${appState.analysisResults.slice(1, 6).length} harm√¥nicos`;
            document.getElementById('audioInfo').classList.add('playing');

            setTimeout(() => {
                stopAllAudio();
            }, duration * 1000);
        }

        function playFullSpectrum() {
            if (appState.analysisResults.length === 0) {
                showMessage('‚ùå Execute a an√°lise primeiro!', 'error');
                return;
            }

            stopAllAudio();

            const volume = document.getElementById('volumeControl').value / 100;
            const duration = parseFloat(document.getElementById('durationControl').value);
            const hasBreathing = document.getElementById('breathingControl').checked;
            const audioCtx = initAudioContext();
            if (!audioCtx) return;

            const allOscillators = [];

            appState.analysisResults.forEach((result, index) => {
                const harmVolume = volume * Math.pow(0.6, index);
                const oscillator = createOscillator(
                    result.frequency, 
                    index === 0 ? 'sawtooth' : 'sine', 
                    harmVolume
                );

                if (!oscillator) return;

                oscillator.gainNode.gain.linearRampToValueAtTime(harmVolume, audioCtx.currentTime + 0.2);
                oscillator.gainNode.gain.linearRampToValueAtTime(harmVolume * 0.8, audioCtx.currentTime + 0.5);
                oscillator.gainNode.gain.setValueAtTime(harmVolume * 0.8, audioCtx.currentTime + duration - 0.3);
                oscillator.gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration);

                if (hasBreathing) {
                    addBreathingEffect(oscillator.gainNode, audioCtx, duration);
                }

                oscillator.oscillator.start(audioCtx.currentTime);
                oscillator.oscillator.stop(audioCtx.currentTime + duration);

                allOscillators.push(oscillator);
            });

            appState.oscillators = allOscillators;
            appState.isPlaying = true;

            document.querySelectorAll('.audio-btn')[2].classList.add('playing');
            document.getElementById('audioInfo').innerHTML = `üéº Tocando espectro completo: ${appState.analysisResults.length} frequ√™ncias`;
            document.getElementById('audioInfo').classList.add('playing');

            setTimeout(() => {
                stopAllAudio();
            }, duration * 1000);
        }

        function stopAllAudio() {
            if (appState.audioContext) {
                appState.oscillators.forEach(osc => {
                    try {
                        if (osc.oscillator) {
                            osc.oscillator.stop();
                        }
                    } catch (e) {
                        // Oscilador j√° foi parado
                    }
                });
            }

            appState.oscillators = [];
            appState.isPlaying = false;

            document.querySelectorAll('.audio-btn').forEach(btn => btn.classList.remove('playing'));
            document.getElementById('audioInfo').classList.remove('playing');
            document.getElementById('audioInfo').innerHTML = 'Preview sonoro parado';
        }

        function updateAudioInfo() {
            const audioInfo = document.getElementById('audioInfo');
            
            if (appState.analysisResults.length === 0) {
                audioInfo.innerHTML = 'Execute a an√°lise para gerar preview sonoro';
                return;
            }

            const drone = appState.analysisResults[0];
            const harmonicsCount = appState.analysisResults.length - 1;
            
            audioInfo.innerHTML = `
                üéµ <strong>Drone:</strong> ${Math.round(drone.frequency)} Hz (${drone.note}${drone.octave})<br>
                üé∫ <strong>Trombetas:</strong> ${harmonicsCount} harm√¥nicos dispon√≠veis<br>
                üí° Clique nos bot√µes acima para ouvir o preview
            `;
        }

        // Gerenciamento de projetos
        function saveProject() {
            try {
                const projectData = {
                    name: document.querySelector('.project-name').value,
                    geometry: document.getElementById('geometryInput').value,
                    soundSpeed: document.getElementById('soundSpeedInput').value,
                    mouthpiece: document.getElementById('mouthpieceInput').value,
                    results: appState.analysisResults,
                    timestamp: new Date().toISOString(),
                    version: '2.0'
                };
                
                const projectName = projectData.name || 'projeto_sem_nome';
                localStorage.setItem(`didgeridoo_${projectName}`, JSON.stringify(projectData));
                
                showMessage('üíæ Projeto salvo com sucesso!');
                
            } catch (error) {
                console.error('Erro ao salvar:', error);
                showMessage(`‚ùå Erro ao salvar: ${error.message}`, 'error');
            }
        }

        function loadProject() {
            const projectName = prompt('Nome do projeto para carregar:');
            if (!projectName) return;
            
            const projectData = localStorage.getItem(`didgeridoo_${projectName}`);
            if (!projectData) {
                showMessage('‚ùå Projeto n√£o encontrado!', 'error');
                return;
            }
            
            try {
                const data = JSON.parse(projectData);
                
                document.querySelector('.project-name').value = data.name || projectName;
                document.getElementById('geometryInput').value = data.geometry || '';
                document.getElementById('soundSpeedInput').value = data.soundSpeed || '343';
                document.getElementById('mouthpieceInput').value = data.mouthpiece || '28';
                
                showMessage('üìÅ Projeto carregado com sucesso!');
                setTimeout(() => analyzeGeometry(), 500);
                
            } catch (e) {
                showMessage('‚ùå Erro ao carregar projeto!', 'error');
            }
        }

        function exportData() {
            if (appState.currentMode === 'construction') {
                exportConstructionData();
                return;
            }
            
            if (appState.analysisResults.length === 0) {
                showMessage('‚ùå Nenhum resultado para exportar', 'error');
                return;
            }
            
            let csv = 'Harm√¥nico,Frequ√™ncia (Hz),Nota,Oitava,Desvio (centavos),Imped√¢ncia (MŒ©)\n';
            
            appState.analysisResults.forEach(result => {
                csv += `${result.harmonic},${result.frequency.toFixed(2)},${result.note},${result.octave},${result.centDiff},${result.impedance.toFixed(3)}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `didgeridoo_analise_${new Date().toISOString().slice(0, 10)}.csv`;
            link.click();
            
            URL.revokeObjectURL(url);
            showMessage('üìä Dados exportados em CSV!');
        }

        function exportConstructionData() {
            const resultsDiv = document.getElementById('constructionResults');
            if (resultsDiv.style.display === 'none') {
                showMessage('‚ùå Calcule as dimens√µes primeiro', 'error');
                return;
            }

            let csv = '# Dados de Constru√ß√£o\n';
            csv += `Comprimento Total,${document.getElementById('totalLengthResult').textContent}\n`;
            csv += `Di√¢metro Externo,${document.getElementById('externalDiameterResult').textContent}\n`;
            csv += `Volume Interno,${document.getElementById('internalVolumeResult').textContent}\n`;

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `construcao_didgeridoo_${new Date().toISOString().slice(0, 10)}.csv`;
            link.click();
            
            URL.revokeObjectURL(url);
            showMessage('üìä Dados de constru√ß√£o exportados!');
        }

        // Utilit√°rios
        function showMessage(text, type = 'success') {
            const statusElement = document.getElementById('statusMessage');
            const messageClass = type === 'error' ? 'error-message' : 'success-message';
            
            statusElement.innerHTML = `<div class="${messageClass} fade-in">${text}</div>`;
            
            setTimeout(() => {
                statusElement.innerHTML = '';
            }, 5000);
        }

        function showLoading(show) {
            const loading = document.getElementById('loadingIndicator');
            loading.classList.toggle('active', show);
            appState.isAnalyzing = show;
        }

        // Redimensionar canvas quando necess√°rio
        window.addEventListener('resize', function() {
            setTimeout(updateVisualization, 100);
        });

        // Auto-an√°lise inicial
        setTimeout(function() {
            analyzeGeometry();
        }, 1000);
    </script>
</body>
</html>